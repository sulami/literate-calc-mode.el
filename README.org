#+TITLE: Literate Calc Mode

[[https://melpa.org/#/literate-calc-mode][file:https://melpa.org/packages/literate-calc-mode-badge.svg]]

Literate programming for =M-x calc=. There is an [[http://sulami.github.io/posts/literate-calc-mode/][announcement blog
post]].

Displays inline results for calculations, supports variables and
updates as you type (if you want). Also works in your favourite markup
mode.

#+caption: Demo
[[file:./scrot.png]]

* Installing

Simply grab it from [[https://melpa.org/][MELPA]].

** [[https://github.com/jwiegley/use-package][use-package]]

#+begin_src emacs-lisp
(use-package literate-calc-mode
  :ensure t)
#+end_src

** [[https://github.com/raxod502/straight.el][straight.el]]

#+begin_src emacs-lisp
(straight-use-package 'literate-calc-mode)
#+end_src

** package.el

[[https://melpa.org/#/getting-started][Ensure you have MELPA available.]]

=M-x package-install=, select =literate-calc-mode=.

** Manual

Just fetch [[file:literate-calc-mode.el][literate-calc-mode.el]], save it somewhere and load it into
Emacs.

* Configuration

There is a =M-x customize= group named after the mode which contains
the following options:

| ~literate-calc-mode-inhibit-line-functions~ | Hook functions called for each line to test whether to inhibit calculation |

There is currently a single inhibitor, which comes installed by
default:

- ~literate-calc-mode-inhibit-in-src-blocks~ :: Prevents evaluation inside org-mode ~src~ blocks

Of course you can also just ~setq~ the options directly.

* Use

There is both a major ~literate-calc-mode~ and a minor
~literate-calc-minor-mode~. The major mode does some basic syntax
highlighting, while the minor mode only evaluates all calc statements
while typing.

The minor mode works quite well with org-/markdown mode or other
markup language major modes.

There are also some functions which can be called without any mode
being active:

| =M-x literate-calc-eval-line=      | Evaluates a single line                        |
| =M-x literate-calc-eval-buffer=    | Evaluates the whole buffer                     |
| =M-x literate-calc-insert-results= | Evaluates the whole buffer and inserts results |
| =M-x literate-calc-clear-overlays= | Removes all overlays and clears variables      |
| =M-x literate-calc-remove-results= | Removes all results and clears variables       |

** Using Units

You can simply append units to your values like so:

#+begin_src fundamental
Flour = 500g => Flour: 500 g
#+end_src

Unit conversion (and other complex functions) can be used by invoking
the matching [[https://www.gnu.org/software/emacs/manual/html_node/calc/Function-Index.html][Algebraic Function]].

#+begin_src fundamental
= usimplify(1m + 3mm) => 1.003 m
#+end_src

You can also use unknown mathematical symbols:

#+begin_src fundamental
= x*2 + x-3 => 3 x - 3
#+end_src

** Evaluation in Org

Org-mode source blocks can be evaluated (~C-c C-c~ by default).

If ~:results~ is set to ~value~, which is the default, a block returns
its last result. If ~:results~ is set to ~output~, it will return the
entire block, annotated with results.

Local variables can be defined in header arguments as ~:var a=38 b=4~.

* Full Example

#+begin_src fundamental
This is a literate calc file.

Lines without "=" are ignored.

All results starting with "=>" are an overlay generated by
literate-calc-mode. That means they are displayed in Emacs, but not
actually in the buffer/file contents.

We can calculate a value like so:

= 2 + 2 => 4

If there is any string on the left hand side, it becomes a bound
variable.

Pi = 3.14159 => Pi: 3.14159

We can use this variable below the definiton.

Tau = Pi * 2 => Tau: 6.28318

Results are calculated using Emacs' own calc, so you can use formulas
as well.

= round(Pi, 2) => 3.14

Later bindings shadow earlier ones:

Pi = 3 => Pi: 3

= Pi => 3

Variable names can have spaces as well:

Monthly Expenses = 500 => Monthly Expenses: 500

Monthly Income = 1000 => Monthly Income: 1000

Annual Savings = 12 * (Monthly Income - Monthly Expenses) => Annual Savings: 6000

All values are recalculated on every update in a spreadsheet-like
fashion.

Calc also has a lot of advanced features, like arrays:

Numbers = [1 2 3] => Numbers: [1, 2, 3]

= 3 Numbers => [3, 6, 9]

#+end_src

* Roadmap

There are some additional features I'm currently thinking about.

** Semantic Highlighting

One of the original inspirations was [[http://tydligapp.com/][Tydlig]], which does similar
things, but also has semantic highlighting. That means, variables are
highlighted in different colours, but always the same one for a given
variable, so that you can see where it's used at a glance.

I might steal some code from [[https://github.com/Fanael/rainbow-identifiers][rainbow-identifiers]], which is one of the
[[https://github.com/ankurdave/color-identifiers-mode][shorter existing implementations]] around, and adapt that to our needs.

